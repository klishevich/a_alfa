'use strict';

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/* eslint import/no-extraneous-dependencies: [2, {"devDependencies": true}] */

var buffer = require('vinyl-buffer');
var del = require('del');
var fs = require('fs');
var gm = require('gulp-gm');
var gulp = require('gulp');
var hbs = require('handlebars');
var imagemin = require('gulp-imagemin');
var rename = require('gulp-rename');
var merge = require('merge-stream');
var path = require('path');
var spritesmith = require('gulp.spritesmith');

var SIZES = ['s', 'm', 'l', 'xl'];
var DIMENSIONS = {
    s: [15, 12],
    m: [20, 15],
    l: [22, 17],
    xl: [24, 20]
};

var COMPONENT_DIR = './';
var SPRITES_IMG_DIR = './images/sprites';
var CHUNKS_IMG_DIR = './images/chunks';

function getImageHeightBySize(size) {
    var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    return {
        width: DIMENSIONS[size][0] * ratio,
        height: DIMENSIONS[size][1] * ratio
    };
}

function optimizeGmFile(file) {
    return file.noProfile().quality(60).colors(24);
}

gulp.task('clean:flag-icon', function () {
    return del([COMPONENT_DIR + '/flag-icon_size_*.css', SPRITES_IMG_DIR, CHUNKS_IMG_DIR]);
});

SIZES.forEach(function (size) {
    var cssChunksTemplate = hbs.compile(fs.readFileSync(COMPONENT_DIR + '/flag-icon.chunks.css.hbs').toString());
    var cssChunksData = { size: size, chunks: [] };

    // Process 2-char country code files only (ignore subregions)
    gulp.task('flag-icon:resize-' + size, function () {
        return gulp.src('../../node_modules/region-flags/png/??.png').pipe(rename(function (path) {
            path.basename = path.basename.toLowerCase();
        }))
        // You need graphicsmagick installed on your system:
        // https://github.com/scalableminds/gulp-gm#graphicsmagick-or-imagemagick
        .pipe(gm(function (file) {
            return file.resize(getImageHeightBySize(size, 2).width, getImageHeightBySize(size, 2).height);
        })).pipe(gm(function (file, done) {
            // We need to run through new dimensions & resize with even numbers if it has odd ones
            // https://github.com/twolfson/gulp.spritesmith/issues/57
            // https://github.com/katapad/evenizer
            file.size(function (error, dimensions) {
                var width = dimensions.width,
                    height = dimensions.height;


                if (error) throw error;

                var east = width % 2 === 1 ? 1 : 0;
                var south = height % 2 === 1 ? 1 : 0;

                if (east || south) {
                    done(null, optimizeGmFile(file.resize(width + east, height + south, '!' // Override aspect ratio
                    )));
                } else {
                    done(null, optimizeGmFile(file));
                }
            });
        })).pipe(gulp.dest(CHUNKS_IMG_DIR + '/' + size + '/2x')).pipe(gm(function (file, done) {
            file.size(function (error, dimensions) {
                if (error) throw error;

                done(null, optimizeGmFile(file.resize(dimensions.width / 2, dimensions.height / 2)));
            });
        }))
        // We need to save files on disk cause of spritesmith's retinaSrcFilter inability to read streams
        .pipe(gulp.dest(CHUNKS_IMG_DIR + '/' + size + '/1x'));
    });

    gulp.task('flag-icon:chunks-' + size, ['flag-icon:resize-' + size], function () {
        return gulp.src(CHUNKS_IMG_DIR + '/' + size + '/1x/*.png').pipe(gm(function (file, done) {
            file.size(function (error, dimensions) {
                if (error) throw error;

                var url = file.source.split(/\/1x\//g);
                var name = path.basename(file.source, path.extname(file.source));
                cssChunksData.chunks.push({
                    width: dimensions.width + 'px',
                    height: dimensions.height + 'px',
                    name: name,
                    url: CHUNKS_IMG_DIR + '/' + size + '/1x/' + url[1]
                });

                done(null, file);
            });
        })).on('end', function () {
            cssChunksData.retinaChunks = cssChunksData.chunks.map(function (item) {
                return {
                    name: item.name,
                    url: item.url.replace('/1x/', '/2x/')
                };
            });

            fs.writeFileSync(COMPONENT_DIR + '/flag-icon_size_' + size + '.chunks.css', cssChunksTemplate(cssChunksData));
        });
    });

    gulp.task('flag-icon:sprite-' + size, ['flag-icon:resize-' + size], function () {
        var spriteData = gulp.src(CHUNKS_IMG_DIR + '/' + size + '/**/*.png').pipe(spritesmith({
            cssName: 'flag-icon_size_' + size + '.sprite.css',
            imgName: 'flag-icon_size_' + size + '@1x.png',
            retinaImgName: 'flag-icon_size_' + size + '@2x.png',
            retinaSrcFilter: [CHUNKS_IMG_DIR + '/' + size + '/2x/*.png'],
            cssTemplate: COMPONENT_DIR + '/flag-icon.sprite.css.hbs',
            cssOpts: { size: size },
            cssVarMap: function cssVarMap(sprite) {
                sprite.selector = '.flag-icon_country_' + sprite.name;

                // https://github.com/twolfson/gulp.spritesmith/issues/124
                if (sprite.source_image.indexOf('2x') !== -1) {
                    sprite.name += '-2x';
                }
            }
        }));

        var imageStream = spriteData.img.pipe(buffer()).pipe(imagemin([imagemin.optipng({ optimizationLevel: 7 })])).pipe(gulp.dest(SPRITES_IMG_DIR));

        var cssStream = spriteData.css.pipe(gulp.dest(COMPONENT_DIR));

        return merge(imageStream, cssStream);
    });
});

gulp.task('default', ['clean:flag-icon'].concat(SIZES.map(function (size) {
    return 'flag-icon:chunks-' + size;
})).concat(SIZES.map(function (size) {
    return 'flag-icon:sprite-' + size;
})));
//# sourceMappingURL=flag-icon.gulpfile.js.map
