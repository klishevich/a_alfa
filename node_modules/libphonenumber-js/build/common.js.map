{"version":3,"sources":["../source/common.js"],"names":["parse_phone_number_digits","parse_national_number_and_country_calling_code","matches_entirely","DASHES","SLASHES","DOTS","WHITESPACE","BRACKETS","TILDES","VALID_PUNCTUATION","PLUS_CHARS","LEADING_PLUS_CHARS_PATTERN","RegExp","MAX_LENGTH_COUNTRY_CODE","DIGIT_MAPPINGS","number","test","drop_and_substitute_characters","metadata","i","length","countryCallingCode","slice","countryCallingCodes","text","regular_expression","matched_groups","match","replacements","replaced","character","replacement","toUpperCase"],"mappings":"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","file":"common.js","sourcesContent":["// `DASHES` will be right after the opening square bracket of the \"character class\"\r\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\r\nconst SLASHES = '\\uFF0F/'\r\nconst DOTS = '\\uFF0E.'\r\nconst WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\r\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\r\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\r\n\r\n// Regular expression of acceptable punctuation found in phone numbers. This\r\n// excludes punctuation found as a leading character only. This consists of dash\r\n// characters, white space characters, full stops, slashes, square brackets,\r\n// parentheses and tildes. Full-width variants are also present.\r\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\r\n\r\nexport const PLUS_CHARS = '+\\uFF0B'\r\nconst LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')\r\n\r\n// The maximum length of the country calling code.\r\nconst MAX_LENGTH_COUNTRY_CODE = 3\r\n\r\n// These mappings map a character (key) to a specific digit that should\r\n// replace it for normalization purposes. Non-European digits that\r\n// may be used in phone numbers are mapped to a European equivalent.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport const DIGIT_MAPPINGS =\r\n{\r\n\t'0': '0',\r\n\t'1': '1',\r\n\t'2': '2',\r\n\t'3': '3',\r\n\t'4': '4',\r\n\t'5': '5',\r\n\t'6': '6',\r\n\t'7': '7',\r\n\t'8': '8',\r\n\t'9': '9',\r\n\t'\\uFF10': '0', // Fullwidth digit 0\r\n\t'\\uFF11': '1', // Fullwidth digit 1\r\n\t'\\uFF12': '2', // Fullwidth digit 2\r\n\t'\\uFF13': '3', // Fullwidth digit 3\r\n\t'\\uFF14': '4', // Fullwidth digit 4\r\n\t'\\uFF15': '5', // Fullwidth digit 5\r\n\t'\\uFF16': '6', // Fullwidth digit 6\r\n\t'\\uFF17': '7', // Fullwidth digit 7\r\n\t'\\uFF18': '8', // Fullwidth digit 8\r\n\t'\\uFF19': '9', // Fullwidth digit 9\r\n\t'\\u0660': '0', // Arabic-indic digit 0\r\n\t'\\u0661': '1', // Arabic-indic digit 1\r\n\t'\\u0662': '2', // Arabic-indic digit 2\r\n\t'\\u0663': '3', // Arabic-indic digit 3\r\n\t'\\u0664': '4', // Arabic-indic digit 4\r\n\t'\\u0665': '5', // Arabic-indic digit 5\r\n\t'\\u0666': '6', // Arabic-indic digit 6\r\n\t'\\u0667': '7', // Arabic-indic digit 7\r\n\t'\\u0668': '8', // Arabic-indic digit 8\r\n\t'\\u0669': '9', // Arabic-indic digit 9\r\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\r\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\r\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\r\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\r\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\r\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\r\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\r\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\r\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\r\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\r\n}\r\n\r\n/**\r\n * Drops all punctuation leaving only digits and the leading `+` sign (if any).\r\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\r\n *\r\n * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n *\r\n * @param  {string} number\r\n * @return {string}\r\n */\r\nexport function parse_phone_number_digits(number)\r\n{\r\n\treturn (LEADING_PLUS_CHARS_PATTERN.test(number) ? '+' : '') +\r\n\t\tdrop_and_substitute_characters(number, DIGIT_MAPPINGS)\r\n}\r\n\r\n// Parses a formatted phone number\r\n// and returns `{ country_calling_code, number }`\r\n// where `number` is the national (significant) phone number.\r\n//\r\n// (aka `maybeExtractCountryPhoneCode`)\r\n//\r\nexport function parse_national_number_and_country_calling_code(number, metadata)\r\n{\r\n\tnumber = parse_phone_number_digits(number)\r\n\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then don't extract country phone code.\r\n\tif (number[0] !== '+')\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0')\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\r\n\t{\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\r\n\t\tif (metadata.countryCallingCodes()[countryCallingCode])\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n// Checks whether the entire input sequence can be matched\r\n// against the regular expression.\r\nexport function matches_entirely(text = '', regular_expression)\r\n{\r\n\tif (typeof regular_expression === 'string')\r\n\t{\r\n\t\tregular_expression = '^(?:' + regular_expression + ')$'\r\n\t}\r\n\r\n\tconst matched_groups = text.match(regular_expression)\r\n\treturn matched_groups !== null && matched_groups[0].length === text.length\r\n}\r\n\r\n// For any character not being part of `replacements`\r\n// it is removed from the phone number.\r\nfunction drop_and_substitute_characters(text, replacements)\r\n{\r\n\tlet replaced = ''\r\n\r\n\tfor (const character of text)\r\n\t{\r\n\t\tconst replacement = replacements[character.toUpperCase()]\r\n\r\n\t\tif (replacement)\r\n\t\t{\r\n\t\t\treplaced += replacement\r\n\t\t}\r\n\t}\r\n\r\n\treturn replaced\r\n}"]}